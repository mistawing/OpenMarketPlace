// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Transaction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Transaction_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case pending // = 0
  case completed // = 1
  case error // = 2
  case refundStarted // = 3
  case refunded // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .completed
    case 2: self = .error
    case 3: self = .refundStarted
    case 4: self = .refunded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .completed: return 1
    case .error: return 2
    case .refundStarted: return 3
    case .refunded: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Transaction_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_Status] = [
    .pending,
    .completed,
    .error,
    .refundStarted,
    .refunded,
  ]
}

#endif  // swift(>=4.2)

enum Transaction_ErrorCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case insufficientBalance // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .insufficientBalance
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .insufficientBalance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .insufficientBalance: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Transaction_ErrorCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_ErrorCategory] = [
    .insufficientBalance,
  ]
}

#endif  // swift(>=4.2)

struct Transaction_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var category: Transaction_ErrorCategory = .insufficientBalance

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_MoneyAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currencyID: String = String()

  var amount: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_QueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Transaction_QueryRequest.QueryType = .transactionID

  var param: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum QueryType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transactionID // = 0
    case payerID // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .transactionID
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transactionID
      case 1: self = .payerID
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transactionID: return 0
      case .payerID: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Transaction_QueryRequest.QueryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_QueryRequest.QueryType] = [
    .transactionID,
    .payerID,
  ]
}

#endif  // swift(>=4.2)

struct Transaction_QueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [Transaction_QueryResultItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_QueryResultItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Transaction_QueryResultItem.TypeEnum = .transfer

  var transactionID: String = String()

  var moneyAmount: Transaction_MoneyAmount {
    get {return _moneyAmount ?? Transaction_MoneyAmount()}
    set {_moneyAmount = newValue}
  }
  /// Returns true if `moneyAmount` has been explicitly set.
  var hasMoneyAmount: Bool {return self._moneyAmount != nil}
  /// Clears the value of `moneyAmount`. Subsequent reads from it will return its default value.
  mutating func clearMoneyAmount() {self._moneyAmount = nil}

  var createdAt: String = String()

  var payerID: String = String()

  var recipientID: String = String()

  var status: Transaction_Status = .pending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transfer // = 0
    case pay // = 1
    case refund // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .transfer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transfer
      case 1: self = .pay
      case 2: self = .refund
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transfer: return 0
      case .pay: return 1
      case .refund: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _moneyAmount: Transaction_MoneyAmount? = nil
}

#if swift(>=4.2)

extension Transaction_QueryResultItem.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_QueryResultItem.TypeEnum] = [
    .transfer,
    .pay,
    .refund,
  ]
}

#endif  // swift(>=4.2)

struct Transaction_PaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Transaction_PaymentRequest.TypeEnum = .transfer

  var recipientID: String = String()

  var moneyAmount: Transaction_MoneyAmount {
    get {return _moneyAmount ?? Transaction_MoneyAmount()}
    set {_moneyAmount = newValue}
  }
  /// Returns true if `moneyAmount` has been explicitly set.
  var hasMoneyAmount: Bool {return self._moneyAmount != nil}
  /// Clears the value of `moneyAmount`. Subsequent reads from it will return its default value.
  mutating func clearMoneyAmount() {self._moneyAmount = nil}

  var note: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transfer // = 0
    case pay // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .transfer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transfer
      case 1: self = .pay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transfer: return 0
      case .pay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _moneyAmount: Transaction_MoneyAmount? = nil
}

#if swift(>=4.2)

extension Transaction_PaymentRequest.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_PaymentRequest.TypeEnum] = [
    .transfer,
    .pay,
  ]
}

#endif  // swift(>=4.2)

/// Response message with the greetings
struct Transaction_PaymentResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_RefundRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_RefundResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Transaction_Error {
    get {return _error ?? Transaction_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var refund: Transaction_PaymentRefund {
    get {return _refund ?? Transaction_PaymentRefund()}
    set {_refund = newValue}
  }
  /// Returns true if `refund` has been explicitly set.
  var hasRefund: Bool {return self._refund != nil}
  /// Clears the value of `refund`. Subsequent reads from it will return its default value.
  mutating func clearRefund() {self._refund = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Transaction_Error? = nil
  fileprivate var _refund: Transaction_PaymentRefund? = nil
}

struct Transaction_PaymentRefund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var refundID: String = String()

  var transactionID: String = String()

  var moneyAmount: Transaction_MoneyAmount {
    get {return _moneyAmount ?? Transaction_MoneyAmount()}
    set {_moneyAmount = newValue}
  }
  /// Returns true if `moneyAmount` has been explicitly set.
  var hasMoneyAmount: Bool {return self._moneyAmount != nil}
  /// Clears the value of `moneyAmount`. Subsequent reads from it will return its default value.
  mutating func clearMoneyAmount() {self._moneyAmount = nil}

  var createdAt: String = String()

  var reason: String = String()

  var status: Transaction_Status = .pending

  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _moneyAmount: Transaction_MoneyAmount? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "transaction"

extension Transaction_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETED"),
    2: .same(proto: "ERROR"),
    3: .same(proto: "REFUND_STARTED"),
    4: .same(proto: "REFUNDED"),
  ]
}

extension Transaction_ErrorCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSUFFICIENT_BALANCE"),
  ]
}

extension Transaction_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.category)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .insufficientBalance {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_Error, rhs: Transaction_Error) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_MoneyAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoneyAmount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currencyId"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.currencyID)
      case 2: try decoder.decodeSingularDoubleField(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_MoneyAmount, rhs: Transaction_MoneyAmount) -> Bool {
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.param)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .transactionID {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.param.isEmpty {
      try visitor.visitSingularStringField(value: self.param, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_QueryRequest, rhs: Transaction_QueryRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.param != rhs.param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryRequest.QueryType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSACTION_ID"),
    1: .same(proto: "PAYER_ID"),
  ]
}

extension Transaction_QueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_QueryResult, rhs: Transaction_QueryResult) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryResultItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResultItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "transactionId"),
    3: .same(proto: "moneyAmount"),
    4: .same(proto: "createdAt"),
    5: .same(proto: "payerId"),
    6: .same(proto: "recipientId"),
    7: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.transactionID)
      case 3: try decoder.decodeSingularMessageField(value: &self._moneyAmount)
      case 4: try decoder.decodeSingularStringField(value: &self.createdAt)
      case 5: try decoder.decodeSingularStringField(value: &self.payerID)
      case 6: try decoder.decodeSingularStringField(value: &self.recipientID)
      case 7: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .transfer {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    if let v = self._moneyAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 4)
    }
    if !self.payerID.isEmpty {
      try visitor.visitSingularStringField(value: self.payerID, fieldNumber: 5)
    }
    if !self.recipientID.isEmpty {
      try visitor.visitSingularStringField(value: self.recipientID, fieldNumber: 6)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_QueryResultItem, rhs: Transaction_QueryResultItem) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs._moneyAmount != rhs._moneyAmount {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.payerID != rhs.payerID {return false}
    if lhs.recipientID != rhs.recipientID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryResultItem.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFER"),
    1: .same(proto: "PAY"),
    2: .same(proto: "REFUND"),
  ]
}

extension Transaction_PaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "moneyAmount"),
    4: .same(proto: "note"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.recipientID)
      case 3: try decoder.decodeSingularMessageField(value: &self._moneyAmount)
      case 4: try decoder.decodeSingularStringField(value: &self.note)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .transfer {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.recipientID.isEmpty {
      try visitor.visitSingularStringField(value: self.recipientID, fieldNumber: 2)
    }
    if let v = self._moneyAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularStringField(value: self.note, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_PaymentRequest, rhs: Transaction_PaymentRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.recipientID != rhs.recipientID {return false}
    if lhs._moneyAmount != rhs._moneyAmount {return false}
    if lhs.note != rhs.note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_PaymentRequest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFER"),
    1: .same(proto: "PAY"),
  ]
}

extension Transaction_PaymentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_PaymentResult, rhs: Transaction_PaymentResult) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_RefundRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefundRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
    2: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      case 2: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_RefundRequest, rhs: Transaction_RefundRequest) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_RefundResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefundResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "refund"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._error)
      case 2: try decoder.decodeSingularMessageField(value: &self._refund)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._refund {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_RefundResult, rhs: Transaction_RefundResult) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._refund != rhs._refund {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_PaymentRefund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentRefund"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refundId"),
    2: .same(proto: "transactionId"),
    3: .same(proto: "moneyAmount"),
    4: .same(proto: "createdAt"),
    5: .same(proto: "reason"),
    6: .same(proto: "status"),
    7: .same(proto: "updatedAt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.refundID)
      case 2: try decoder.decodeSingularStringField(value: &self.transactionID)
      case 3: try decoder.decodeSingularMessageField(value: &self._moneyAmount)
      case 4: try decoder.decodeSingularStringField(value: &self.createdAt)
      case 5: try decoder.decodeSingularStringField(value: &self.reason)
      case 6: try decoder.decodeSingularEnumField(value: &self.status)
      case 7: try decoder.decodeSingularStringField(value: &self.updatedAt)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refundID.isEmpty {
      try visitor.visitSingularStringField(value: self.refundID, fieldNumber: 1)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    if let v = self._moneyAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.createdAt.isEmpty {
      try visitor.visitSingularStringField(value: self.createdAt, fieldNumber: 4)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_PaymentRefund, rhs: Transaction_PaymentRefund) -> Bool {
    if lhs.refundID != rhs.refundID {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs._moneyAmount != rhs._moneyAmount {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.status != rhs.status {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
